#!/usr/bin/env zsh
# -*- mode: sh; sh-indentation: 4; indent-tabs-mode: nil; sh-basic-offset: 4; -*-

# Copyright (c) 2023 Sebastian Gniazdowski

# Run as script? Or as a function? Supports both ways.

iqnc()
{
# Preamble – emulate & 0=…
0=${${${(M)${0::=${(%):-%x}}:#/*}:-$PWD/$0}:A}

source $0:h:h/share/preamble.inc.zsh --script --fun --cleanup

local -A Opts;local -a opts
int/nc::init-sm-con Opts opts "$@"||return 30
set -- "$reply[@]"
eval "$REPLY"

zmodload zsh/db/gdbm&>>$NCLOG||\
    iqerr "No zsh/db/gdbm module" "" "," " no screen saving available…"
command mkdir -p $NCSCRDB:h
[[ -f $NCSCRDB ]]||\
  (){local -A Screens;zmodload zsh/db/gdbm&&builtin ztie -d db/gdbm -f $NCSCRDB Screens;}

command touch $NCSCRDB

iqw(){ 
    ((ZUI[started]))||return
    -zui_glib_msg "${@//\{[^\}]#\}/}"
}

iqnc_mime_setup(){
    zstyle ':mime:*' browser-style running x tty
    zstyle ':mime:*' x-browsers google-chrome
    zstyle ':mime:*' tty-browsers w3m links
    zstyle :mime:browser:new:google-chrome: command %b %u
    zstyle :mime:browser:running:google-chrome: command %b %u
    zstyle :mime:browser:new:w3m: command  %b %u
    zstyle :mime:browser:running:w3m: command  %b %u
    zstyle :mime: mailcap  $APPDIR/.mailcap ~/.mailcap /etc/mailcap
    zstyle :mime: mime-types $APPDIR/.mime.types ~/.mime.types /etc/mime.types
    autoload -Uz zsh-mime-setup pick-web-browser
    zsh-mime-setup
}

iqnc_util_swap4(){
    local Q=$1 Q0=$2
    shift 0+2
    local -a vars=("$@")

    : ${(P)vars[Q0+1]::=${(P)vars[4]}}
    : ${(P)vars[4]::=${(P)vars[Q+1]}}
}

iqnc_util_set_current_idx(){
    integer IN=ZUI[PREV_CURRENT_IDX] prev_idx=ZUI[PREV_CURRENT_IDX]
    local QPATH=${ZUI[QPATH]:+_$ZUI[QPATH]}
        print «$prev_idx>>/tmp/reply
        print $ZUI[CURRENT_IDX]>>/tmp/reply
    # Tree
    if ((ZUI[GEN_B_IDX]==CIN));then
       [[ $prev_idx == ($ZUI[CURRENT_IDX_PVIEW_BKP$QPATH]|\
$ZUI[CURRENT_IDX_HIST_BKP]|$ZUI[CURRENT_IDX_TAGS_BKP]) ]]&&\
            prev_idx=${ZUI[CURRENT_IDX_MAIN_BKP]:-5}
        print °$prev_idx>>/tmp/reply
    # Preview
    elif ((ZUI[GEN_B_IDX]==VIEW));then
        [[ $prev_idx == ($ZUI[CURRENT_IDX_MAIN_BKP]|$ZUI[CURRENT_IDX_HIST_BKP]|\
$ZUI[CURRENT_IDX_TAGS_BKP]) ]]&&\
            prev_idx=${${ZUI[CURRENT_IDX_PVIEW_BKP$QPATH]:#0#}:-5}
    elif ((ZUI[GEN_B_IDX]==CQUE));then
        [[ $prev_idx == ($ZUI[CURRENT_IDX_PVIEW_BKP$QPATH]|\
$ZUI[CURRENT_IDX_MAIN_BKP]|$ZUI[CURRENT_IDX_TAGS_BKP]) ]]&&\
        prev_idx=${${ZUI[CURRENT_IDX_HIST_BKP]:#0#}:-5}
    elif ((ZUI[GEN_B_IDX]==TAGS));then
        [[ $prev_idx == ($ZUI[CURRENT_IDX_PVIEW_BKP$QPATH]|$ZUI[CURRENT_IDX_MAIN_BKP]|$ZUI[CURRENT_IDX_HIST_BKP]) ]]&&\
            prev_idx=${${ZUI[CURRENT_IDX_TAGS_BKP]:#0#}:-5}
    fi
    if ((IN!=prev_idx));then
        ZUI[CURRENT_IDX]=$prev_idx
    fi
    if ((!ZUI[UNIQ_MODE]&&!$#ZUI[SEARCH_BUFFER]&&\
            ZUI[CURRENT_IDX]<=${${(On)ZUILIST_NONSELECTABLE_ELEMENTS}[1]}));then
        ZUI[CURRENT_IDX]=${${(On)ZUILIST_NONSELECTABLE_ELEMENTS}[1]}+1
    fi
    ZUI[PREV_CURRENT_IDX]=$prev_idx
    print ̣.°.̣$prev_idx/$ZUI[CURRENT_IDX]>>/tmp/reply
}

iqnc_cmd_synh_switch(){
    ((ZUI[SRC_HIGHLIGHT]=1-ZUI[SRC_HIGHLIGHT]))
    if iqnc_hub;then
        ((ZUI[SRC_HIGHLIGHT]))&&local txt=" ON"||local txt=" OFF"
        iqw "Syntax highlighting switched" $txt
    fi
}

iqnc_cmd_next(){
    integer q=$1 in=ZUI[GEN_B_IDX]

    if (($#1));then
        ZUI[GEN_B_IDX]=$q
    # Third: no-arg
    else
        ((ZUI[GEN_B_IDX]=(1+ZUI[GEN_B_IDX])%VIEWS))
    fi
    iqnc_view_switch $in $ZUI[GEN_B_IDX]
    iqnc_set_prompt
    iqnc_hub
    return 0
}

# Swaps search buffers and command bufs, saves current idx
iqnc_view_switch(){
    integer in=$2 in0=$1
    ZUI[VIEW_CHANGE]=1
    local QPATH=${ZUI[QPATH]:+_$ZUI[QPATH]} QTXT
    ZUI[PREV_GEN_B_IDX]=$in0

    noglob iqnc_util_swap4 $in $in0 \
        ZUI[SEARCH_BUFFER_GLOBAL]\
        ZUI[SEARCH_BUFFER_PREVIEW]\
        ZUI[SEARCH_BUFFER_CQUE]\
        ZUI[SEARCH_BUFFER_TAGS]\
        ZUI[SEARCH_BUFFER]

    typeset -g buffer=$ZUI[SEARCH_BUFFER]
    if ((in0==VIEW));then
        ZUI[CURRENT_IDX_PVIEW_BKP$QPATH]=$ZUI[CURRENT_IDX]
    elif ((in0==CQUE));then
        ZUI[CURRENT_IDX_HIST_BKP]=$ZUI[CURRENT_IDX]
    elif ((in0==TAGS));then
        ZUI[CURRENT_IDX_TAGS_BKP]=$ZUI[CURRENT_IDX]
    elif ((in0==CIN));then
        ZUI[CURRENT_IDX_MAIN_BKP]=$ZUI[CURRENT_IDX]
    fi
    ZUI[PREV_CURRENT_IDX]=$ZUI[CURRENT_IDX]
}

iqnc_exec_command_cb(){
    integer QEXISTS
    local CMD=${(Q@)${(@)${(@zA)ZUI[QUERY_BUFFER]}[1]}}
    ZUI[COMMAND]=$ZUI[QUERY_BUFFER]
    {
        if [[ $ZUI[COMMAND] != [[:space:]]# ]];then
            builtin print -r -- $ZUI[COMMAND]>>!$NCCHIST
        else
            THROW "No command entered ($ZUI[COMMAND]), " "" "" "cannot execute"
        fi
        # No such command?
        builtin type ${CMD#\!}&>/dev/null||\
            THROW "No such command" ": " "" $CMD
    } always {
        if CATCH \*;then
            iqw "$CAUGHT[@]"
            TRY_BLOCK_ERROR=0
        else
             cmd-push-screen
             iqnc_reset_hist
             iqnc_cmd_next $CIN

            #iqnc_hub
            iqw "Executed command: " \`$CMD\` " which returned: " $ZUI[RET]
        fi
    }
    ZUI[QUERY_BUFFER]= ZUI[COMMAND]=
}

iqnc_query_change_cb(){
    iqnc_set_prompt ${1%e}
    ZUI[VIEW_CHANGE]=1
}

iqnc_reset_hist(){
    ok/qlnum -U $NCCHIST&&ZUI[CMD_NO]=$((REPLY+1))
    ok/qlnum -U $NCSHIST&&ZUI[SEARCH_NO]=$((REPLY+1))
}

iqnc_create_histories(){
    : ${NCCHIST:=${XDG_CACHE HOME:-$HOME/.cache/n-commodore}/n-commmodore-cmd.hst}
    : ${NCSHIST:=${XDG_CACHE HOME:-$HOME/.cache/n-commodore}/n-commmodore-srch.hst}
    command mkdir -p $NCCHIST:h $NCSHIST:h||return
    [[ ! -f $NCCHIST ]]&&builtin print -n>!$NCCHIST
    [[ ! -f $NCSHIST ]]&&builtin print -n>!$NCSHIST
    iqnc_reset_hist
    return 0
}

iqnc_hist(){
    local TPE=$1 QDIR=$2 FILE
    [[ $TPE == CMD ]]&&FILE=$NCCHIST||FILE=$NCSHIST
    int/nc::read-all-sys -d$FILE
    local -aU h=(${(Oa)reply})
    h=(${(Oa)h})
    ((!$#h))&&{iqw "Command history empty, no change done";return 0;}
    : ${ZUI[${TPE}_NO]:=$#h}
    if ((QDIR));then
        ((++ZUI[${TPE}_NO],ZUI[${TPE}_NO]>$#h+1?(ZUI[${TPE}_NO]=$#h+1):1))
    else
        ((--ZUI[${TPE}_NO],ZUI[${TPE}_NO]<0?(ZUI[${TPE}_NO]=0):1))
    fi
    local ITEM=$h[ZUI[${TPE}_NO]]
    if ((ZUI[${TPE}_NO]<1||ZUI[${TPE}_NO]>$#h));then
        ITEM=
        local D=top
        ((QDIR))&&D=bottom
        iqw "At $D of history"
    else
        [[ $ITEM == $~NC[WRONGSTR] && $ZUI[${TPE}_NO] -ne 1 ]]&&\
            {iqw "Unknown problem with history occurred…";return 1;}
    fi
    ZUI[QUERY_BUFFER]=$ITEM buffer=$ITEM
}

iqnc_hist_top(){
    local T D=$1
    if ((ZUI[IN_QUERY]==PR_SEARCH));then
        T=SEARCH
    elif ((ZUI[IN_QUERY]==PR_CMD_EXEC));then
        T=CMD
    fi
    (($#T))&&iqnc_hist $T $D
}

iqnc_set_prompt(){
    local C=${1:-$ZUI[IN_QUERY]}
    if ((C==PR_NONE));then
        ZUI[QUERY_PROMPT]=
    elif ((C==PR_SEARCH));then
        iqnc_search_prompt
    elif ((C==PR_CMD_EXEC));then
        iqnc_exec_prompt
    else
        iqw "Internal error, please report"
    fi
}

iqnc_search_prompt(){
    local T=files
    ((ZUI[GEN_B_IDX]==CIN))&&T=command\ output
    ((ZUI[GEN_B_IDX]==VIEW))&&T=file\ contents
    ((ZUI[GEN_B_IDX]==CQUE))&&T=command\ history
    ((ZUI[GEN_B_IDX]==TAGS))&&T=Ctags\ db

    ZUI[QUERY_PROMPT]="S.keywords of $T: " ZUI[IN_QUERY]=$PR_SEARCH
    typeset -g in_query=$PR_SEARCH
    ZUI[cursor]=$#ZUI[SEARCH_BUFFER]+1
    ZUI[VIEW_CHANGE]=1
}

iqnc_exec_prompt(){
    ZUI[QUERY_PROMPT]="$PWD/:> "
    ZUI[IN_QUERY]=$PR_CMD_EXEC
    typeset -g in_query=$PR_CMD_EXEC
    ZUI[cursor]=$#ZUI[QUERY_BUFFER]+1
    ZUI[VIEW_CHANGE]=1
}

iqnc_db(){
    local VAR_NAME=$1
    [[ -n ${(M)zgdbm_tied:#$VAR_NAME} ]]&&return 0
    builtin ztie -d db/gdbm -f "$NCSCRDB" "$VAR_NAME" &>>$NCLOG||\
        {iqw "Error:" "" "" " cannot open DB";return 1;}
    return 0
}

iqnc_get_cmd_out(){
    local TPE=$1 cmd=("$@[2,-1]")
    if [[ $TPE == whole || -n ${(M)cmd[1,-2]:#builtin} || $cmd[1] == \!* ]];then
        ZUI[TMP]=$(mktemp)
        [[ $cmd[1] == \!* ]]&&iqw "Notice: " "in the same-shell process run ("\
                                    "leading ! detected" ")"
        cmd[1]=${cmd[1]#\!}
        eval "$cmd[@]"&>!$ZUI[TMP]
        ZUI[RET]=$?
        local CMD_PT="(${(~j.|.)${=NC_LS_LIKE_COMMANDS}})"

        if [[ $cmd[1] == $~CMD_PT || ($cmd[1] == (noglob|command) &&\
                $cmd[2] == $~CMD_PT) ]]
        then
            reply=("${(@f)$(builtin print -C2 -a ${(@f)$(<$ZUI[TMP])})}")
        else
            reply=("${(@f)$(<$ZUI[TMP])}")
        fi
        rm -f $ZUI[TMP]
    else
        ((Q0_SAVE_PIPE))&&exec {Q0_SAVE_PIPE}<&-
        Q0_SAVE_PIPE=0
        [[ $cmd[1] == noglob ]]&&{local -a stdbuf1=(noglob $stdbuf1);cmd[1]=();}
        [[ $cmd[1] == builtin ]]&&local -a stdbuf1=(${(M)stdbuf1:#noglob})
        [[ $cmd[1] == command ]]&&cmd[1]=()
        [[ -n $aliases[$cmd[1]] ]]&&cmd[1]=(${(s: :)aliases[$cmd[1]]})
        coproc {$stdbuf1 "$cmd[@]" 2>&1 </dev/tty;}
        ZUI[RET]=$?
    fi

    return $ZUI[RET]
}

separ(){
    REPLY="$ZUI[YELLOW]${(l:COLUMNS*3::—:):-}$ZUI[FMT_END]";
}

# Utils
cmd-ret(){print Press enter to continue…; read -k1;}
cmd-hide(){zcurses end;}
cmd-show(){zcurses refresh;}
cmd-synh-switch(){iqnc_cmd_synh_switch;}

# navigation
cmd-page-down(){
    current_idx=current_idx+page_height/2
    [[ "$current_idx" -gt "$last_element" ]] && current_idx=last_element;
    -zui_listin_compute_first_to_show_idx
}
cmd-page-up(){
    current_idx=current_idx-page_height/2
    [[ "$current_idx" -lt 1 ]] && current_idx=1;
    -zui_listin_compute_first_to_show_idx
}
# Views
cmd-command-history-view(){iqnc_cmd_next $CQUE;}
cmd-contents-view(){iqnc_cmd_next $VIEW;}
cmd-main-view(){iqnc_cmd_next $CIN;}
cmd-tags-view(){iqnc_cmd_next $TAGS;}
cmd-set-view(){local -A Qe=(main 0 preview 1 hist 2 tags 3 "" 0);iqnc_cmd_next $Qe[$1];}
cmd-show-stdin(){ZUI[HAVE_0_INPUT]=1;ZUI[IO_COUNT]=33;iqnc_hub;}
# Commands
cmd-open-cmd(){zcurses end;eval "$@";-zui_glib_refresh;}
cmd-open-tig(){curses end;command tig "$@";-zui_glib_refresh;}
cmd-commit(){zcurses end;command git commit -v "$@";cmd-ret;-zui_glib_refresh;}
cmd-push(){zcurses end;command git push "$@";cmd-ret;-zui_glib_refresh;}
cmd-pull(){zcurses end;command git pull "$@";cmd-ret;-zui_glib_refresh;}
cmd-stage-line(){iqnc_stage_line;}

# Prompt states
cmd-exec-prompt(){iqnc_exec_prompt;}
cmd-search-prompt(){iqnc_search_prompt;}
cmd-toggle-prompt(){zui::toggle-prompt;}

# Histories
cmd-exec-prev-hist(){iqnc_hist CMD 0;}
cmd-exec-next-hist(){iqnc_hist CMD 1;}
cmd-search-next-hist(){iqnc_hist SEARCH 1;}
cmd-search-prev-hist(){iqnc_hist SEARCH 0;}
cmd-next-hist(){iqnc_hist_top 1;}
cmd-prev-hist(){iqnc_hist_top 0;}
cmd-next-command(){iqnc_command_top 1;}
cmd-prev-command(){iqnc_command_top 0;}

# directories
cmd-pwd-up(){((ZUI[GEN_B_IDX]!=$CIN))&&{iqnc_cmd_next $CIN;return 0;}; local PPWD=$PWD;if builtin cd -q -- $PWD:h;then iqnc_push_pwd $PPWD; iqw "Current CWD is: " "" "" $PWD(D);iqnc_cmd_next $CIN; else iqw "Cannot change CWD to: " "" "" ..;fi;}
cmd-cd(){local Q=${(M)1:#-*};[[ $1 == -* ]]&&shift;if builtin cd -q -- "$1";then [[ $Q != -q ]]&&{iqw "CWD changed to: " "" "" $PWD; iqnc_cmd_next $CIN;};else iqw "Cannot change CWD to: " "" "" $1;fi;}
cmd-prev-pwd(){iqnc_pop_pwd&&cmd-cd "$REPLY";}

# cursor
cmd-cursor-left(){ZUI[cursor]=$((ZUI[cursor]-1));}
cmd-cursor-right(){ZUI[cursor]=$((ZUI[cursor]+1));}
cmd-cursor-word-left(){
    ZUI[cursor]=$((ZUI[cursor]-=
        ${#${(M)buffer[1,ZUI[cursor]-1]%%[[:space:]]#[^[:space:]]##}}));}
cmd-cursor-word-right(){
    ZUI[cursor]=$((ZUI[cursor]+=
        ${#${(M)buffer[ZUI[cursor],-1]##[[:space:]]#[^[:space:]]##}}));}

iqnc_cnt_idx_to_db_idx(){
    integer QIDX QCIDX=$1
    (($+WScreens))||local -A WScreens
    iqnc_db WScreens||return 1
    screens=("${(k@nM)WScreens:#SCREEN_<->}")
    ((QCIDX==0))&&QCIDX=WScreens[SCREEN_NO]
    ((QCIDX>$#screens))&&: ${WScreens[SCREEN_NO]::=${QCIDX::=$#screens}}
    ((QCIDX<1))&&: ${WScreens[SCREEN_NO]::=${QCIDX::=1}}
    QIDX=${screens[QCIDX]#SCREEN_}
    REPLY=$QIDX
}

# screens
cmd-push-screen(){
    local -A WScreens
    iqnc_db WScreens||return 1
    integer QIDX=${${${(kOn)WScreens[(I)SCREEN_<->]}[1]}#SCREEN_}
    QIDX+=1
    repeat 1;do
        WScreens[SCREEN_$QIDX]=${(F)qitems}
        WScreens[SCREEN_PWD_$QIDX]=$PWD
        WScreens[SCREEN_VIEW_$QIDX]=$ZUI[GEN_B_IDX]
        WScreens[SCREEN_QPATH_$QIDX]=$ZUI[QPATH]
        WScreens[SCREEN_QUERY_$QIDX]=$ZUI[IN_QUERY]
        WScreens[SCREEN_SEARCH_$QIDX]=$ZUI[SEARCH_BUFFER]
        WScreens[SCREEN_CMD_$QIDX]=$ZUI[QUERY_BUFFER]
        WScreens[SCREEN_CUR_IDX_$QIDX]=$current_idx
        WScreens[SCREEN_FROM_$QIDX]=$from_what_idx_list_is_shown
        WScreens[SCREEN_CUR_SEG_$QIDX]=$current_segment
        WScreens[SCREEN_CURSOR_$QIDX]=$ZUI[cursor]
        WScreens[SCREEN_COLORING_$QIDX]=$ZUI[COLORING_PATTERN]
    done
    WScreens[SCREEN_NO]=$#WScreens[(I)SCREEN_<->]
    iqw "" "Screen " "#$#WScreens[(I)SCREEN_<->] " pushed, " PWD is: " ${PWD/$HOME/\~}
}

cmd-remove-screen(){
    (($+WScreens))||local -A WScreens
    iqnc_db WScreens||return 1
    iqnc_cnt_idx_to_db_idx
    builtin unset "WScreens[SCREEN_$REPLY]"
    builtin unset "WScreens[SCREEN_PWD_$REPLY]"
    iqw "Screen " "#$WScreens[SCREEN_NO] " "successfully " "removed"
}

cmd-fetch-screen(){
    integer QCIDX=$1
    iqnc_cnt_idx_to_db_idx $QCIDX
    iqnc_fill_screen $REPLY $QCIDX
    -zui_glib_fly_array_refresh 1
}

cmd-prune-screens(){
    (($+WScreens))||local -A WScreens
    iqnc_db WScreens||return 1
    integer i cnt=$#WScreens[(I)SCREEN_<->]
    iqw "Pruning all: " $cnt "" " screens" "" "…"
    for ((i=cnt;i>=1;i--));do
        cmd-remove-screen $i
    done
}
cmd-prev-screen(){
    (($+WScreens))||local -A WScreens
    iqnc_db WScreens||return 1
    ((WScreens[SCREEN_NO]=WScreens[SCREEN_NO]>1?WScreens[SCREEN_NO]-1:1))
    cmd-fetch-screen $WScreens[SCREEN_NO]
}

cmd-next-screen(){
    (($+WScreens))||local -A WScreens
    iqnc_db WScreens||return 1

    integer QCNT=${#WScreens[(I)SCREEN_<->]}
    ((WScreens[SCREEN_NO]=WScreens[SCREEN_NO]<QCNT?WScreens[SCREEN_NO]+1:QCNT))
    cmd-fetch-screen $WScreens[SCREEN_NO]
}

cmd-item-to-prompt(){
    ((current_idx<=0))&&return 1
    zui-process-buffer2 $__list[current_idx]||return 1
    local WORD=$ZUI_PB2_QWORDS[current_segment]
    int/nc::prune-esc -e -v WORD $WORD
    buffer+=$WORD" "
    ((ZUI[cursor]+=$#WORD+1))
}

cmd-pwd-to-prompt(){
    buffer+=$PWD" "
    ((ZUI[cursor]+=$#PWD+1))
}

cmd-command-mode-toggle() {
    if [[ $ZUI[cmd-mode] == pipe ]];then
        ZUI[cmd-mode]=whole
        iqw "Command capture mode: " "" "" whole ", the same-shell process"
    elif [[ $ZUI[cmd-mode] != pipe ]];then
        ZUI[cmd-mode]=pipe
        iqw "Command capture mode: " "" "" pipe ", separate subshell process"
    fi
}

cmd-help(){iqnc_fill_help;}

if ((!$+Opts[--refresh])); then
    ok/qnstr $PWD:A&&local APP=$REPLY||local APP=unknown
    readonly CIN=0 VIEW=1 CQUE=2 TAGS=3 VIEWS=4
    readonly PR_NONE=0 PR_SEARCH=1 PR_CMD_EXEC=3
    : ${ZUI[cmd-mode]:=pipe}
    ZUI[SRC_HIGHLIGHT]=1
    -zui_glib_cleanup deserialize:"iqnc_$APP"
    -zui_glib_init app:"iqnc_$APP" app_name:"NC Console"
    emulate -L zsh -o extendedglob -o typesetsilent -o warncreateglobal -o combiningchars -o rcquotes -o noshortloops -o nopromptsubst
    -zui_glib_init2 # after emulate
    ZUI[GEN_B_IDX]=0 ZUI[PREVIEW_FILE_TYPE]=
    typeset -g ZUILIST_TRACK_SEGMENTS=1
    ZUI[SPECIAL_COMMAND_CALLBACK]=iqnc_exec_command_cb
    ZUI[QUERY_CHANGE_CALLBACK]=iqnc_query_change_cb
    ZUI[reset_current_segment]=no

    # Needed for immediate output from coprocesses (disables buffering).
    ((${+commands[stdbuf]}))&& \
        local -a stdbuf1=( stdbuf -o0 -i0 ) stdbuf2=( stdbuf -o0 -i0 )
    ((${+commands[gstdbuf]}))&& \
        local -a stdbuf1=( gstdbuf -o0 -i0 ) stdbuf2=( gstdbuf -o0 -i0 )

    ZUI[COLORING_MATCH_MULTIPLE]=1
    ZUI[COLORING_COLOR]=$ZUI[BOLD]$ZUI[YELLOW]

    -zui_glib_store_default_app_config b:instant_search 1
    -zui_glib_store_default_app_config s:select_mode "quit"   # Quit event loop on text-selection
    -zui_glib_store_default_app_config b:text_bar "[F1 tree][F2 preview][F3 history][F4 Ctags][F7 Synh][F8 remove scrn][Shift-Up CD ..][Shift-Down Prev. Dir]"
    -zui_glib_store_default_app_config b:status_size 6
    -zui_glib_store_default_app_config b:status_pointer 1
    -zui_glib_store_default_app_config b:text_select 1        # Allow selection of text
    -zui_glib_store_default_app_config s:timeout 5
    -zui_glib_store_default_app_config s:mark "white MAGENTA reverse"
    -zui_glib_store_default_app_config s:text_mode off
    -zui_glib_store_default_app_config b:top_anchors 0
    ZUI[UNIQ_MODE]=0
    [[ $1 == open ]]&&shift
    if [[ -n $* ]];then
        ZUI[SEARCH_BUFFER]=$*
        ZUI[cursor]=$#ZUI[SEARCH_BUFFER]+1
        ZUI[START_IN_QUERY]=$PR_SEARCH
    else
        ZUI[START_IN_QUERY]=$PR_CMD_EXEC
        ZUI[cursor]=$#ZUI[QUERY_BUFFER]+1
    fi
    iqnc_set_prompt $ZUI[START_IN_QUERY]

    local -a qitems iq0items q0input q0input_proc
    integer Q0_SAVE_PIPE tmout
    if int/nc::test-stdin Q0_SAVE_PIPE REPLY;then
        ZUI[FIRST_0_INPUT]=$REPLY
        ZUI[HAVE_0_INPUT]=1 ZUI[IO_COUNT]=30
    fi
    iqnc_create_histories
    cmd-exec-prompt
fi

#    zui::bindkey F3 "{print q:$ZUI[mark]}"
zui::bindkey F9 '{print \\n cursor:$ZUI[cursor], cmdno:$ZUI[CMD_NO], query:$ZUI[IN_QUERY], qbuf: $ZUI[QUERY_BUFFER], view:$ZUI[SEARCH_BUFFER_PREVIEW], gl:$ZUI[SEARCH_BUFFER_GLOBAL], sbuff:$ZUI[SEARCH_BUFFER], current:$ZUI[CURRENT_IDX], PVIEW_Q:$ZUI[CURRENT_IDX_PVIEW_BKP_$ZUI[QPATH]], PVIEW:$ZUI[CURRENT_IDX_PVIEW_BKP], TAG:$ZUI[CURRENT_IDX_TAGS_BKP], main:$ZUI[CURRENT_IDX_MAIN_BKP] sptr:$ZUI[status_pointer]|tee -a /tmp/reply;}'
zui::bindkey F10 '{builtin source $NC_CON_DIR/iqnc --refresh||\
                    iqw -r "Reload finished with error: " $?;}'
zui::bindkey F14 '{builtin zcurses end;sleep 3;}'
unsetopt warncreateglobal
builtin source -- $NCCFG
setopt warncreateglobal

iqnc_get_command(){
    REPLY=${NC_DEFAULT_LS_COMMAND:-$NC_DEFAULT_COMMAND}
}

iqnc_push_pwd(){
    local -a h=(${(Q)${(z@)ZUI[PWD_HISTORY]}})
    [[ ${1:-$PWD} != $h[-1] ]]&&ZUI[PWD_HISTORY]+=" ${(q)${1:-$PWD}}"
}

iqnc_pop_pwd(){
    local -a qh=(${(Q)${(z@)ZUI[PWD_HISTORY]}})
    qh=($qh)
    REPLY=$PWD;
    [[ $qh == [[:space:]]# ]]&&{iqw "Error: " "NO saved CWD locations";return 1;}
    local DIR=$qh[-1]
    ZUI[PWD_HISTORY]=${(j[ ])${(q)qh[1,-2]}}
    [[ $DIR == [[:space:]]# ]]&&{iqw "Incorrect directory saved in buffer:" \
                                        " "${(qqq)$DIR};return 1;}
    REPLY=$DIR
    return 0
}

iqnc_hub(){
    integer EC
    local -a gener=(iqnc_fill_cmd       # 1
                    iqnc_fill_preview   # 2
                    iqnc_fill_history   # 3
                    iqnc_fill_tags)     # 4
 
    $gener[1+(ZUI[GEN_B_IDX]%VIEWS)]
    EC=$?
    iqnc_set_prompt
    ZUI[VIEW_CHANGE]=1
    ((${3:-0}))||{-zui_glib_fly_array_refresh 1;}

    return EC
}

iqnc_fill_history(){
    ZUI[text_mode]=off
    int/nc::read-all-sys -d$NCCHIST||{iqw "Error reading history…";return 1;}
    ZUI[COLORING_PATTERN]='(#s)[^[:space:]]##~(*[·–—]*)'
    qitems=(${(u)reply}) reply=()
    -zui_glib_special_text "·Command history·"
    separ
    typeset -ga -U ZUILIST_NONSELECTABLE_ELEMENTS=(4 3 2 1)
    qitems=("$REPLY[3,-1]" "$reply[-1]" "$REPLY[3,-1]" "$qitems[@]")
    ZUI[IN_QUERY]=$PR_SEARCH
    in_query=$PR_SEARCH
}

iqnc_fill_preview(){
    local QPATH QTXT
    ZUI[text_mode]=off
    ZUI[COLORING_PATTERN]="·[^·]##·"
    ZUI[COLORING_MATCH_MULTIPLE]=1
    ZUI[COLORING_COLOR]=$ZUI[BOLD]$ZUI[YELLOW]
    if ((ZUI[CURRENT_IDX]>0&&ZUI[PREV_GEN_B_IDX]==CIN&&ZUI[VIEW_CHANGE]==1));then
        zui-process-buffer2 "$__list[ZUI[CURRENT_IDX]]"
        QPATH=${ZUI_PB2_QWORDS[ZUI[CURRENT_SEGMENT]]}
        ZUI[QPATH]=$QPATH
    else
        QPATH=$ZUI[QPATH]
    fi
    int/nc::prune-esc -T $QPATH -v QPATH
    {
        qitems=() iq0items=()
        if [[ -f $QPATH ]];then
            QTXT="Contents of file: ·$QPATH·"\
" located at: ·${${${(M)QPATH##/*}:+$QPATH:h}:-$PWD}/·"
            ((ZUI[SRC_HIGHLIGHT]))||return 0
            int/nc::get-file-type -s -q $QPATH||\
                THROW  "Unknown file type, no syntax highlighting"
            local TPE=$REPLY
            int/nc::get-stx-cmd -q $TPE||\
               THROW "Error: no highlighter command found: bat, {src-,}highlight"
            local -a qcmd=("$reply[@]" "$QPATH")
            iq0items=("${(@f)$($qcmd[@])}")
            iqw "Showing file: " "\`$QPATH:t\`" ", of type: " $TPE
        else
            QTXT="$ZUI[BOLD]$ZUI[RED]!NO SUCH FILE, F1 FOR TREE$ZUI[FMT_END]"
        fi
    } always {
        if CATCH -c \* || [[ $iq0items == $~NC[WRONGSTR] ]];then
            [[ -n $CAUGHT ]]&&{iqw "$CAUGHT[@]";CAUGHT=;}
            [[ -f $QPATH ]]&&iq0items=("${(@f)$(<$QPATH)}")
        fi
        if [[ $iq0items != $~NC[WRONGSTR] ]];then
            qitems=("$iq0items[@]")
        else
            [[ ! -f $QFILE ]]&&qitems=("No such file")||\
                {[[ ! -s $QFILE ]]&&qitems=("File is empty");}
        fi

        reply=()
        -zui_glib_special_text $QTXT
        separ
        typeset -ga -U ZUILIST_NONSELECTABLE_ELEMENTS=(4 3 2 1)
        qitems=("$REPLY" "$reply[1]" "$REPLY" "$qitems[@]")
    }
}

iqnc_fill_cmd(){
    local TXT=() cmd=() CMD_PT QEX
    integer QI
    ZUI[text_mode]=all
    ZUI[COLORING_PATTERN]="·[^·]##·"
    ZUI[COLORING_MATCH_MULTIPLE]=1
    ZUI[COLORING_COLOR]=$ZUI[BOLD]$ZUI[YELLOW]
    ZUI[QIDX]=0
    reply=()

    ZUI[COMMAND]=${1:-$ZUI[COMMAND]}
    [[ $ZUI[COMMAND] != $~NC[WRONGSTR] ]]&&ZUI[HAVE_0_INPUT]=0
    : ${ZUI[COMMAND]:=${NC_DEFAULT_LS_COMMAND:-$NC_DEFAULT_COMMAND}}
    if [[ -n $ZUI[COMMAND] ]];then
        [[ -e $ZUI[QPATH] ]]&&ZUI[COMMAND]=${ZUI[COMMAND]//\%s/${(q)ZUI[QPATH]}}
        [[ -e $ZUI[QPATH] ]]||ZUI[COMMAND]=${ZUI[COMMAND]//\%s/}
        ZUI[COMMAND_PREV]=$ZUI[COMMAND]
        cmd=("${(z@)ZUI[COMMAND]}")
        QEX=${(M)cmd[1]#\!}
        cmd[1]=${cmd[1]#\!}
        ZUI[COMMAND]=
        CMD_PT="(${(~j.|.)${(@)=NC_LS_LIKE_COMMANDS}})"
        # Include ls-options
        if [[ -n $NC_DEFAULT_LS_LIKE_OPTS && ($cmd[1] == $~CMD_PT ||\
            $cmd[1] == (command|noglob|sudo) && $cmd[2] == $~CMD_PT) ]]
        then
            QI=2;[[ $cmd[2] == $~CMD_PT ]]&&QI=3
            cmd[QI,0]=(${(s: :)NC_DEFAULT_LS_LIKE_OPTS})
            ZUI[ls-command]=1
        else
            ZUI[ls-command]=0
        fi

        if [[ $cmd[1] == cd || $cmd[1] == builtin && $cmd[2] == cd ]];then
            iqw "Changing directory to: " "" "" "$cmd[-1]"
            iqnc_push_pwd 
            eval "$cmd[@]"
            iqnc_fill_cmd
            return
        fi

        iqnc_get_cmd_out $ZUI[cmd-mode] $QEX$cmd[1] "${(@)cmd[2,-1]}"
        if [[ $ZUI[cmd-mode] == whole || -n $QEX ]]; then
            iq0items=("$reply[@]")
        else
            iq0items=() q0input=()
            ZUI[HAVE_0_INPUT]=1 ZUI[IO_COUNT]=30
        fi

        -zui_glib_special_text "Output of cmd: ·$ZUI[COMMAND_PREV]· run in: ·$PWD·:" TXT
        if [[ $iq0items = $~NC[WRONGSTR] && $ZUI[cmd-mode] = whole ]]
        then
            iqw "Command " "$cmd" "" " had no output"
            return
        fi
    else
        -zui_glib_special_text "Showing files in: ·$PWD·" TXT
        iq0items=(**/*~*~(N.,@))
    fi
    (($+Opts[-s]))&&iq0items=("${(@on)iq0items}")
    (($+Opts[-R]))&&iq0items=("${(a@nO)iq0items}")
    [[ -n $iq0items[1,3] ]]&&\
        {ok/qcolreduce -- "$iq0items[@]";iq0items=("$reply[@]");}

    typeset -ga -U ZUILIST_NONSELECTABLE_ELEMENTS=(4 3 2 1)
    separ
    qitems=("$REPLY" "$TXT" "$REPLY" "$iq0items[@]")
    ZUI[VIEW_CHANGE]=1
}

iqnc_fill_0(){
    integer QFLAG
    ((Q0_SAVE_PIPE))&&\
        int/nc::read-all -u$Q0_SAVE_PIPE -t0 -x50
    ((!Q0_SAVE_PIPE))&&\
        int/nc::read-all -p -t0 -x50

    QFLAG=$#reply
    ZUI[read-all-failed]=$((!QFLAG))
    ((ZUI[IO_COUNT]-=!QFLAG))
    ((ZUI[IO_COUNT]<0))&&ZUI[HAVE_0_INPUT]=0&&return

    local ql had_read=0
    integer q0idx=$#q0input+1
    if ((!$#q0input&&QFLAG));then
        q0input[q0idx]=$ZUI[FIRST_0_INPUT]$reply[1]
        shift reply
    fi

    ((QFLAG))&&ok/qcolreduce "$reply[@]"

    q0input+=("$reply[@]")
    q0input_proc=("$q0input[@]")
    (($+Opts[-s]))&&q0input_proc=("${(@on)q0input_proc}")
    (($+Opts[-R]))&&q0input_proc=("${(a@nO)q0input_proc}")
    ((ZUI[ls-command]))&&q0input_proc=(
            "${(@f)$(print -C2 -a -r -- $q0input_proc[@])}" )
    if ((ZUI[GEN_B_IDX]%VIEWS==0));then
        reply=()
        -zui_glib_special_text "Output of cmd: ·$ZUI[COMMAND_PREV]· run in: ·$PWD·:"
        local TXT=$reply[1] 
        separ
        #local -a q0items=("$qitems[@]")
        qitems=($REPLY "$TXT" $REPLY "$q0input_proc[@]")
        #[[ -n ${qitems:|q0items} ]]
       -zui_glib_fly_array_refresh 1
    fi
}

iqnc_fill_screen(){
    integer QIDX=$1 QCIDX=$2
    local SPWD spwd=()
    (($+WScreens))||local -A WScreens
    iqnc_db WScreens||return 1
    ZUI[COLORING_PATTERN]="((·[^·]##·~(#s)·*)|(#s)· [^[:space:]]##)"

    qitems=("${(@f)WScreens[SCREEN_$QIDX]}")
    [[ -n ${SPWD::=$WScreens[SCREEN_PWD_$QIDX]} ]]&&cmd-cd -q $SPWD
    ZUI[GEN_B_IDX]=${WScreens[SCREEN_VIEW_$QIDX]:-0}
    ZUI[QPATH]=$WScreens[SCREEN_QPATH_$QIDX]
    ZUI[COLORING_PATTERN]=$WScreens[SCREEN_COLORING_$QIDX]
    current_idx=$WScreens[SCREEN_CUR_IDX_$QIDX]
    from_what_idx_list_is_shown=$WScreens[SCREEN_FROM_$QIDX]
    current_segment=$WScreens[SCREEN_CUR_SEG_$QIDX]
    in_query=$WScreens[SCREEN_QUERY_$QIDX]
    ZUI[SEARCH_BUFFER]=$WScreens[SCREEN_SEARCH_$QIDX]
    ZUI[QUERY_BUFFER]=$WScreens[SCREEN_CMD_$QIDX]
    ZUI[cursor]=$WScreens[SCREEN_CURSOR_$QIDX]
    if ((in_query==PR_CMD_EXEC));then
        buffer=$ZUI[QUERY_BUFFER]
    elif ((in_query==PR_SEARCH));then
        buffer=$ZUI[SEARCH_BUFFER]
    fi
    iqnc_set_prompt
    [[ -n $SPWD ]]&&spwd=(", PWD is: " "" "" ${SPWD//$HOME/\~})
    iqw "" "Showing screen no: " "" "" "#$QCIDX" "$spwd[@]"
}

local -a qa_tag_data
local -A TAG

iqnc_find_tags_index() {
    local q
    local -a p

    # Read tags file
    p=( (../)#TAGS(N) )
    TAG[file]=${${(On)p}[1]}
    [[ -f ./TAGS ]] && TAG[file]=$PWD/TAGS
    if [[ -n $TAG[file] ]]; then
        TAG[git-or-project]=${${TAG[file]:a}:h:t}
    else
        TAG[git-or-project]="<unknown>"
    fi

    # Pre-process found index
    TAG[file-pp]=${TAG[file]/TAGS/.TAGS}.z
    if [[ -n $TAG[file] && -f $TAG[file] && ( ! -f $TAG[file-pp] || $TAG[file] -nt $TAG[file-pp]) ]]
    then
        local sed_
        (($+commands[sed]))&&sed_=sed
        (($+commands[gsed]))&&sed_=gsed
        (($+commands[$sed_]))||{iqw "No sed found, cannot read TAGS";return;}
         # Generate simplified file – append the filename at each line,
        # so that it's not only at the preamble line
        command $sed_ -r -n $'/^\x0c$/ { n; s/,[^,]*$//;s/^/\x02/; h; d;}; G; y/\\n/,/; p' $TAG[file] >! $TAG[file-pp]
    fi

    # Read index, and as index is found, establish git main dir for it
    if [[ -n $TAG[file] && -f $TAG[file-pp] ]]; then
        qa_tag_data=( ${"${(@f)"$(<${TAG[file-pp]})"}"##[[:space:]]##} )
        # Cleanup functions and their preambles
        qa_tag_data=( ${qa_tag_data[@]/(#b)(\([^\)]#\))[[:space:]]#[\{]*($'\x7f')/$match[1]$match[2]} )
        qa_tag_data=( ${qa_tag_data[@]/(#b)[[:space:]]\#*($'\x7f')/$match[1]} )
        local outside_git="${PWD%/${$(git rev-parse --quiet --show-prefix 2>/dev/null)%/}}"
        if [[ -d $outside_git && -n ${${(M)PWD##$outside_git}##$HOME} ]]; then
            TAG[git-or-project]=$outside_git:t
            TAG[repo-dir]=$outside_git
        else
            TAG[git-or-project]=$TAG[file]:h:t
            TAG[repo-dir]=$TAG[file]:h
        fi
        return 0
    fi
    return 1
}

iqnc_fill_tags(){
    ZUI[COLORING_PATTERN]="((#s)[^[:space:]]##|·[^·]##·)"
    iqnc_find_tags_index || {iqw "No TAGS file in ../…"; return 1;}
    qa_tag_data=(${(o)qa_tag_data})
    qa=(${qa_tag_data//(#b)([^$'\177']##)$'\177'([^$'\1']##)*/${(r:39:: :)match[2]} $match[1]})
    iqnc_search_prompt
    separ
    qitems=($REPLY[3,-1]
            "·TAG· (func, var, etc.)                 ·CODE SNIPPET·"
            $REPLY[3,-1]
            $qa)
}

iqnc_fill_help(){
    ZUI[COLORING_PATTERN]="((·[^·]##·~(#s)·*)|(#s)· [^[:space:]]##)"
    separ
    qitems=($REPLY[3,-1] "·N–Commodore help:·" $REPLY[3,-1]
            "${(@f)$(<$NCTXT/HELP_CONTENTS)}" )
    -zui_glib_fly_array_refresh 1
}

# Read & publish Configure/make output
-zui-standard-timeout-callback(){
    local TM=$ZUI[text_mode]
    ((ZUI[GEN_B_IDX]==0))&&ZUI[text_mode]=all||ZUI[text_mode]=off
    # Ensure cursor is visible
    if ((ZUI[CURRENT_IDX]<5&&!$#ZUI[SEARCH_BUFFER]&&!ZUI[UNIQ_MODE]));then
        ((__last_element>=5))&&\
            { ZUI[CURRENT_IDX]=5;-zui_list_verify_vars;ZUI[redraw]=1;}
    fi

    ZUI[VIEW_CHANGE]=$((ZUI[VIEW_CHANGE]+${#${TM:#$ZUI[text_mode]}}))
    ZUI[VIEW_CHANGE]=$((ZUI[VIEW_CHANGE]+${${ZUI[COMMAND]:+1}:-0}))
    typeset -ga -U ZUILIST_NONSELECTABLE_ELEMENTS=(4 3 2 1)
    ((!ZUI[HAVE_0_INPUT]&&!ZUI[VIEW_CHANGE]))&&return

    if ((ZUI[HAVE_0_INPUT]));then
        iqnc_fill_0
    fi

    ((ZUI[VIEW_CHANGE]))||return 0
    if [[ -n $ZUI[COMMAND] ]];then
        local CMD=$ZUI[COMMAND]
        iqnc_cmd_next $CIN $ZUI[GEN_B_IDX]
    fi
    builtin unset 'ZUI[COMMAND]'
    iqnc_util_set_current_idx
    -zui_list_verify_vars 1
    -zui_glib_fly_array_refresh 1
    ZUI[VIEW_CHANGE]=0
    ZUI[PREV_GEN_B_IDX]=$ZUI[GEN_B_IDX]
    return 0
}

if (($+Opts[--refresh])); then
    iqw "Reload went OK, status normal"
    return 0
fi

## Start application ##
iqnc_mime_setup
-zui_glib_msg "" "@@@ " "Welcome to " "NC System " "console" " v0.8" " @@@";
-zui_glib_msg "" "@@@ " "Press " Shift-F1 " to show the " "HELP screen" " @@@";
integer QFLAG EC
iqnc_push_pwd
iqnc_hub 1 1 1
ZUI[redraw]=1
while (( 1 )); do
    ZUI[VIEW_CHANGE]=1
    builtin print -rn -- $terminfo[smcup]$termcap[ti]
    ZUI[started]=1
    zui-event-loop a:qitems
    builtin print -rn -- $terminfo[rmcup]$termcap[te]
    QFLAG=0
    # exit?
    [[ -z $REPLY ]]&&break
    local QFILE= REPLY_SAVE=$REPLY; integer QIDX=0
    [[ $ZUI[SEARCH_BUFFER] != $~NC[WRONGSTR] ]]&&
        {iqnc_create_histories; builtin print $ZUI[SEARCH_BUFFER]>>!$NCSHIST;}

    if [[ $ZUI[GEN_B_IDX] = $TAGS ]];then
        integer QI=0
        [[ -n $ZUI[SEARCH_BUFFER] || $ZUI[UNIQ_MODE] -eq 1 ]]||QI=-4
        [[ -n $ZUI[SEARCH_BUFFER] ]]&&\
            repeat 1; do typeset +U -ga __slist=("$__qlist[@]");done
        if [[ $ZUI[SEARCH_BUFFER] ]]&&-zui_sys_get_match_line QIDX; then
            QI+=QIDX
        else
            QI+=ZUI[CURRENT_IDX]
        fi
        if [[ $qa_tag_data[QI] = (#b)[^$'\177']##$'\177'[^$'\1']##$'\1'\
([^$'\2']##)$'\2'((*)) ]];then
            QFILE=$match[3] QIDX=${match[1]%%,*} QFLAG=1
        fi
    fi

    # …from diff?
    if [[ $QFLAG -eq 0 && -z $ZUI[SEARCH_BUFFER] ]];then
        # …from preview?
        if ((ZUI[GEN_B_IDX]%VIEWS==VIEW));then
            QFILE=$ZUI[QPATH]
            QIDX=ZUI[USER_CURRENT_IDX]
            iqw "Opening " $QFILE " scrolled to line: " "#$QIDX"
        # …tree?
        elif [[ $ZUI[GEN_B_IDX] == ($CIN|$CQUE) && $REPLY_SAVE != *(·|–|—)* ]];then
            QFILE=$REPLY_SAVE
        fi
    # search selection?
    elif [[ $QFLAG -eq 0 ]];then
        # prepare the list var that's needed by -zui_sys_get_match_line
        repeat 1; do typeset +U -ga __slist=("$__qlist[@]");done
        if -zui_sys_get_match_line QIDX; then
            # preview?
            if ((ZUI[GEN_B_IDX]%VIEWS==VIEW));then
                QFILE=$ZUI[QPATH]
                iqw "Opening " "${QFILE:-error ↔ not found}"\
                        " scrolled to line: " "#$QIDX"
            # tags?
            elif ((ZUI[GEN_B_IDX]%VIEWS==PR_CMD_EXEC));then
                iqw "………"
            # or normal?
            elif [[ $ZUI[GEN_B_IDX] == ($CIN|$CQUE) && $REPLY_SAVE != *(·|–|—)* ]];then
                QFILE=$REPLY_SAVE
                QIDX=0
            fi
        fi
    fi

    int/nc::prune-esc -eT -v QFILE $QFILE
    QFILE=${QFILE%%/##}

    # compiler/grep output?
    if [[ ($QFILE == (#b)(#s)((#B)(^:<->)##):(#b)(<->):* ||
            $QFILE == (#b)(#s)((#B)(^:<->)##):*) && \
            ! -e **/$QFILE(#qNY1) ]]
    then
        QFILE=$match[1] QIDX=$match[2]
    fi

    if ((ZUI[GEN_B_IDX]!=CQUE))&&\
        [[ ! -f **/$QFILE(#qNY1) && ! -d **/$QFILE(#qNY1/) ]]
    then
        if n-c prj-dir -q && [[ -e $REPLY ]];then
            if [[ -e $REPLY/**/$QFILE(#qNY1) ]];then
                QFILE=($REPLY/**/$QFILE(#qNY1));QFILE=$QFILE[1]
            elif [[ -e $REPLY/**/$QFILE:t(#qNY1) ]];then
                QFILE=($REPLY/**/$QFILE:t(#qNY1));QFILE=$QFILE[1]
            fi
        fi
    fi

    integer QFLAG=0
    # history
    if ((ZUI[GEN_B_IDX]==CQUE));then
        ZUI[COMMAND]=$QFILE
        ZUI[VIEW_CHANGE]=1
        QFLAG=1
    fi

    if [[ -f **/$QFILE(#qNY1) ]];then
        [[ -f $QFILE ]]||{QFILE=(**/$QFILE(#qNY1));QFILE=$QFILE[1];}
        REPLY=
        if [[ -n $NC_OPEN_CMD ]];then
            REPLY=$NC_OPEN_CMD
        elif ! int/nc::get-editor;then
            EC+=$?
            iqw "" "" "" 'ERROR: Couldn''t find editor, tried '\
                "\$VISUAL (=$VISUAL) " then "" " \$EDITOR (=$EDITOR)"
        fi
        # Run the editor in $REPLY, first cd-ing into project's directory
        if [[ -n $REPLY && $(file -- $QFILE) = (#i)*text* ]];then
            int/nc::run-command -C $PWD \
                "$REPLY" ${${QIDX:#0##}:++$QIDX} -- $QFILE
        else
                local QTMP=${zsh_mime_handlers[$QFILE:e]// (\"|)%?(\"|)/}
                [[ -n $saliases[$QFILE:e] && -n $QTMP ]]&&\
                    iqw "MIME type " $QFILE:e " program run: " "\`$QTMP\`" …||\
                    iqw "No MIME program for extension: " "" ".$QFILE:e"\
                            " you can set it via " "~/.mailcap" " and in" \
                            " ~/.mime-types"
                eval ./$QFILE
        fi
        EC+=$? QFLAG=1
    fi
    if [[ -d **/$QFILE(#qNY1/) ]];then
        [[ -d $QFILE ]]||{QFILE=(**/$QFILE(#qNY1/));QFILE=$QFILE[1];}
        iqw "Changing directory to: " ${QFILE##$PWD/}
        cmd-push-screen
        iqnc_push_pwd
        if builtin cd -q -- $QFILE;then
            iqnc_get_command
            iqnc_fill_cmd $REPLY
        else
            iqw "" "" "" \
                "Cannot CD to dir, PWD is: " $PWD
        fi
        QFLAG=1
    fi

    if ((!QFLAG));then
        iqw "" "" "" "NO SUCH FILE OR DIRECTORY: " $QFILE
    else
        builtin zcurses clear main redraw
        builtin zcurses clear status redraw
    fi
    iqnc_set_prompt
    builtin zcurses refresh
done

-zui_glib_cleanup serialize
builtin print -n $terminfo[rmcup]$termcap[te]
return 0
}
iqnc "$@"

# vim:ft=zsh:tw=80:sw=4:sts=4:et:foldmarker=[[[,]]]
