#!/usr/bin/env zsh
# Input:
# $1 - optional buffer to process (default is $BUFFER)
# $2 - optional parameter containing cursor (default is $CURSOR)
#
# Output:
# NC_PB_WORDS - split of $1 into shell words; array
# NC_PB_WORDS_BEGINNINGS - indexes of first letters of corresponding words in NC_PB_WORDS
# NC_PB_SPACES - white spaces before corresponding words in NC_PB_WORDS
# NC_PB_SELECTED_WORD - index in NC_PB_WORDS pointing to word activated by cursor position
# NC_PB_LEFT - left part of active word
# NC_PB_RIGHT - right part of active word
#

int/@nc::process-buffer() {
    eval "${SNIP_EMULATE_OPTIONS_ZERO:-false}"||\
        0=${${${(M)${0::=${(%):-%x}}:#/*}:-$PWD/$0}:A}

    local MBEGIN MEND MATCH mbegin mend match

    local buf="${1:-$BUFFER}"
    local cursor="${2:-$CURSOR}"

    typeset -ga NC_PB_WORDS=("${(Z+n+)buf}") \
        NC_PB_SPACES=() \
        NC_PB_WORDS_BEGINNINGS=()
    typeset -gi NC_PB_SELECTED_WORD=-1
    typeset NC_PB_LEFT NC_PB_RIGHT
    # (Z+n+) will return 1 element for buf that is empty or only whitespace
    if [[ $buf = ( |$'\t')# ]]; then
        NC_PB_WORDS=()
        integer nwords=0
    else
        integer nwords="${#NC_PB_WORDS}"
    fi

    # Remove NC_PB_WORDS one by one, counting characters,
    # computing beginning of each word, to find
    # place to break the word into 2 halves (for
    # complete_in_word option)

    local i word wordlen
    integer char_count=0

    # (Z) handles spaces nicely, but we need them for the user
    # Also compute words beginnings and the selected word
    for (( i=1; i<=nwords; i++ )); do
        # Remove spurious space generated by Z-flag when
        # input is an unbound '$(' (happens with zsh < 5.1)
        # and also real spaces gathered by an unbound '$(',
        # to handle them in a way normal to this loop
        NC_PB_WORDS[i]="${NC_PB_WORDS[i]%% ##}"
        word="${NC_PB_WORDS[i]}"

        # In general, $buf can start with white spaces
        # We will not search for them, but instead for
        # leading character of current shell word,
        # negated. This is an ambition to completely
        # avoid character classes

        # Remove white spaces
        buf="${buf##(#m)[^$word[1]]#}"
        # Count them
        char_count=char_count+"$#MATCH"
        # This is the beginning of current word
        NC_PB_WORDS_BEGINNINGS[i]=$(( char_count + 1 ))
        # Remember the spaces
        NC_PB_SPACES[i]=$MATCH

        # Remove the word
        wordlen="${#word}"
        [[ "${buf[1,wordlen]}" != $word ]] && return 1 # should not happen unless bug in (z)
        buf="${buf[wordlen+1,-1]}"

        # Spaces point to previous shell word
        # Visual cursor right after spaces (-ge) -> not enough to select previous word (-gt required)
        [[ $NC_PB_SELECTED_WORD -eq -1 && $char_count -gt $cursor ]] && NC_PB_SELECTED_WORD=$(( i-1 ))

        # Actual characters point to current shell word
        # Visual cursor right after letters (-ge) -> enough to select current word
        char_count=char_count+"$#word"
        [[ $NC_PB_SELECTED_WORD -eq -1 && $char_count -ge $cursor ]] && NC_PB_SELECTED_WORD=$i
    done 

    # What's left in $buf can be only white spaces
    char_count=char_count+"$#buf"
    NC_PB_SPACES[i]=$buf

    # Visual cursor right after spaces (-ge) -> enough to select last word
    [[ $NC_PB_SELECTED_WORD -eq -1 && $char_count -ge $cursor ]] && NC_PB_SELECTED_WORD=$(( i-1 ))

    # Divide active word into two halves
    integer diff=$(( cursor - NC_PB_WORDS_BEGINNINGS[NC_PB_SELECTED_WORD] + 1 ))
    word="${NC_PB_WORDS[NC_PB_SELECTED_WORD]}"
    NC_PB_LEFT="${word[1,diff]}"
    NC_PB_RIGHT="${word[diff+1,-1]}"

    [[ $NC_PB_SELECTED_WORD -gt 0 ]]

}
# vim:ft=zsh
